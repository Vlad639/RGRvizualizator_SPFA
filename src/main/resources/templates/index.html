<!DOCTYPE html>
<html lang="en" xmlns="">
<head>
    <link rel="stylesheet" type="text/css" th:href = "@{/css/style.css}">
    <script type="text/javascript" th:src="@{/jQuery.js}"></script>
    <meta charset="UTF-8">
    <title>Title</title>

    <style>
        #build_panel {
            margin-bottom: 40px;
        }

        #prev_step_button {
            margin-right: 20px;
        }

    </style>
</head>


<body>


    <div id = "instrumnet_and_paint_wrapper">
        <div id = "paint_area" th:fragment = "paint_fragment">
            <canvas width='1000' height='800'  id="canvas">Обновите браузер</canvas>
        </div>

        <div id = "instrument_panel">
            <div id = "build_panel">
                <div> <p>Построение</p> </div>
                <div> <button onclick="operationType = 1" >Создать вершину</button> </div>
                <div> <button onclick="operationType = 2" >Выбрать</button> </div>
                <div> <button onclick="connectVertexes()" >Соединить</button> </div>
                <div> <button onclick="" >К визуализации</button> </div>
            </div>

            <div id = "vizualization_div">
                <div> <p>Визуализация</p> </div>
                <button onclick="test()"> Визуализировать </button>

                <div>
                    <button onclick="prevStep()" id = "prev_step_button"> <- </button>
                    <span id = "steps_status"> -/- </span>
                    <button onclick="nextStep()"> -> </button>
                </div>

                <div> <button onclick="" >К редактированию</button> </div>
            </div>

        </div>
    </div>
</body>

<script>

    vertexMaxId = 0;
    lineMaxId = 0;
    vertexRadius = 20;
    vertexArray = [];
    linesArray = [];
    SPFASteps = [];
    selectedVertexesNumbers = 0;

    firstSelectedVertex = null;
    secondSelectedVertex = null;
    stepNumber = 0;

    class Point {
        x = 0;
        y = 0;
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }

    class Vertex {
        id = 0;
        x = 0;
        y = 0;
        selected = false;
        light = false;

        constructor(x, y) {
            this.id = vertexMaxId + 1;
            this.x = x;
            this.y = y;
            vertexMaxId ++;
        }
    }

    class Line {
        id = 0;
        coordinate1;
        coordinate2;
        vertex1;
        vertex2;
        weight = 1;
        light = false;

        constructor(vertex1, vertex2) {
            this.vertex1 = vertex1;
            this.vertex2 = vertex2;

            this.coordinate1 = new Point(vertex1.x, vertex1.y);
            this.coordinate2 = new Point(vertex2.x, vertex2.y);

            this.id = lineMaxId;
            lineMaxId ++;

        }
    }

    var canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d");

    operationType = 1; // 1 - создать, 2 - выбрать

    function clearCanvas(){
        backgroudColor = 'aliceblue';
        ctx.clearRect(0 ,0 , canvas.width, canvas.height);
        ctx.fillStyle = backgroudColor;
        ctx.rect(0 ,0 , canvas.width, canvas.height);
        ctx.fill();
    }

    clearCanvas();

    function drawAllVertexes(){

        if (vertexArray !== null)
            vertexArray.forEach(function(vertex) {

                if (vertex.selected)
                    ctx.fillStyle = 'blueviolet';
                else
                    ctx.fillStyle = 'green';

                if (vertex.light)
                    ctx.fillStyle = 'red';

                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, vertexRadius, 0, 2 * Math.PI, false);

                ctx.strokeStyle = 'black';
                ctx.stroke();
                ctx.fill();

                ctx.font = "14px serif";
                ctx.fillStyle = 'white';
                ctx.fillText(vertex.id, vertex.x, vertex.y);

            })


    }

    function findVertexFromId(id) {
        let result = null;
        if (vertexArray !== null) {
            vertexArray.forEach(function (vertex) {
                if (vertex.id === id) {
                    result = vertex;
                    return "break";
                }
            })
            return result;
        }
    }

    function findLineFromVertexesIds(vertex1Id, vertex2Id) {
        let result = null;
        if (linesArray !== null) {
            linesArray.forEach(function (line) {
                if (line.vertex1.id === vertex1Id && line.vertex2.id === vertex2Id) {
                    result = line;
                    return "break";
                }
            })
            return result;

        }
    }

    function findLineFromId(id){
        let result = null;
        if (linesArray !== null) {
            linesArray.forEach(function (line) {
                if (line.id === id) {
                    result = vertex;
                    return "break";
                }
            })
            return result;
        }
    }

    function updateStepsStatusView(currentStep, allStep){
        text = currentStep + "/" + allStep
        document.getElementById("steps_status").innerText = text;
    }

    function fillSPFAstepsFalseLight(){
        for (let i = 0; i < SPFASteps.length; i++) {
            SPFASteps[i].light = false;
            SPFASteps[i].vertex1.light = false;
        }
    }

    function nextStep(){

        if (stepNumber < SPFASteps.length) {

            fillSPFAstepsFalseLight();

            for (let i = 0; i <= stepNumber; i++) {
                SPFASteps[i].light = true;
                SPFASteps[i].vertex1.light = true;
            }

            updateStepsStatusView(stepNumber + 1, SPFASteps.length);
            stepNumber ++;

        }

        draw();
        console.log(stepNumber);


    }

    function prevStep(){



         if (stepNumber > 0) {

             fillSPFAstepsFalseLight();

             for (let i = 0; i < stepNumber - 1; i++) {
                 SPFASteps[i].light = true;
                 SPFASteps[i].vertex1.light = true;
             }

             updateStepsStatusView(stepNumber - 1, SPFASteps.length);
             stepNumber --;
         }



        draw();
        console.log(stepNumber);

    }

    function test(){

        // JavaScript implementation of SPFA

        // Graph is stored as vector of vector of pairs
// first element of pair store vertex
// second element of pair store weight
        let graph = new Array(100000);

        // Function to add edges in the graph
// connecting a pair of vertex(frm) and weight
// to another vertex(to) in graph
        function addEdge(from, to, weight) {
            graph[from].push([to, weight ]);

        }

        function addEdgesFromLines() {

            if (linesArray !== null)
                linesArray.forEach(function(line) {
                    addEdge(
                        line.vertex1.id,
                        line.vertex2.id,
                        line.weight
                    );
                })

        }

        // Function to print shortest distance from source
        function print_distance(d,V) {
            console.log("Vertex", " ", "Distance" + " from source");

            for (let i = 1; i <= V; i++)
                console.log( i+"     "+ d[i]);

        }

        // Function to compute the SPF algorithm
        function shortestPathFaster(S,V) {
            let d = new Array(V + 1); //Массив с кратчайшими расстояниями

            // Boolean array to check if vertex
            // is present in queue or not
            let inQueue = new Array(V + 1);

            // Initialize the distance from source to
            // other vertex as Integer.MAX_VALUE(infinite)
            for (let i = 0; i <= V; i++)
                d[i] = Number.MAX_VALUE;

            d[S] = 0;

            let q = [];
            q.push(S);
            inQueue[S] = true;

            while (q.length !== 0) {

                // Take the front vertex from Queue
                let u = q[0];
                q.shift();
                inQueue[u] = false;

                // Relaxing all the adjacent edges of
                // vertex taken from the Queue

                console.log(u + ":");

                for (let i = 0; i < graph[u].length; i++) {

                    let v = graph[u][i][0];
                    let weight = graph[u][i][1];

                    console.log(u + "--" + weight + "-->" + v);
                    SPFASteps.push(findLineFromVertexesIds(u, v));


                    if (d[v] > d[u] + weight) {

                        d[v] = d[u] + weight;

                        // Check if vertex v is in Queue or not
                        // if not then push it into the Queue
                        if (!inQueue[v])
                        {
                            q.push(v);
                            inQueue[v] = true;
                        }
                    }
                }
            }

            // Print the result
            print_distance(d, V);
        }

        // Driver code
        let V = 4;
        let S = 1;
        for (let i = 0; i < graph.length; i++)
            graph[i] = [];



        addEdgesFromLines();


        // Calling shortestPathFaster function
        shortestPathFaster(S, V);

// This code is contributed by unknown2108

    }


    function drawAllLines(){

        if (linesArray !== null)
            linesArray.forEach(function(line) {

                arrowColor = 'black';
                headLen = 22; // Длина головы стрелки

                if (line.light)
                    arrowColor = 'red';

                deltaX = Math.abs(line.coordinate2.x - line.coordinate1.x);
                deltaY = Math.abs(line.coordinate1.y - line.coordinate2.y);

                tg = deltaX / deltaY;
                angle = Math.atan(tg);

                vertex1X = line.coordinate1.x;
                vertex1Y = line.coordinate1.y;

                vertex2X = line.coordinate2.x;
                vertex2Y = line.coordinate2.y;

                if (vertex1X < vertex2X)
                    x = vertex2X + vertexRadius * Math.cos(1.5 * Math.PI - angle);
                else
                    x = vertex2X + vertexRadius * Math.cos(1.5 * Math.PI + angle);

                if (vertex1Y < vertex2Y)
                    y = vertex2Y + vertexRadius * Math.sin(1.5 * Math.PI - angle);
                else
                    y = vertex2Y - vertexRadius * Math.sin(1.5 * Math.PI + angle);

                dx = x - vertex1X;
                dy = y - vertex1Y;
                angle = Math.atan2(dy, dx);

                ctx.beginPath();
                ctx.strokeStyle = arrowColor;
                ctx.moveTo(vertex1X, vertex1Y);
                ctx.lineTo(x, y);
                ctx.lineTo(x - headLen * Math.cos(angle - Math.PI / 6), y - headLen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(x, y);
                ctx.lineTo(x - headLen * Math.cos(angle + Math.PI / 6), y - headLen * Math.sin(angle + Math.PI / 6));
                ctx.stroke();

            })

    }

    function setSelectedFalseForAllVertexes(){
        if (vertexArray !== null)
            vertexArray.forEach(function(vertex) {
                vertex.selected = false;
            })
    }

    function draw() {
        clearCanvas();
        drawAllLines();
        drawAllVertexes();
    }

    function connectVertexes(){
            if (selectedVertexesNumbers !== 2) {
                alert("Выбрано не 2 вершины!");
                firstSelectedVertex = null;
                secondSelectedVertex = null;
                setSelectedFalseForAllVertexes();
                selectedVertexesNumbers = 0;
                draw();
            }
            else {
                alert(firstSelectedVertex.id + " ---> " + secondSelectedVertex.id);

                linesArray.push(new Line(firstSelectedVertex, secondSelectedVertex));

                firstSelectedVertex = null;
                secondSelectedVertex = null;
                setSelectedFalseForAllVertexes();
                selectedVertexesNumbers = 0;
                draw();
            }

    }

    function clickOnPaintArea(event){
        x = event.offsetX;
        y = event.offsetY;

        if (operationType === 1) {
            vertexArray.push(new Vertex(x, y));
        }

        if (operationType === 2) {

            if (vertexArray !== null)
                vertexArray.forEach(function(vertex) {
                    if (((vertex.x - x) * (vertex.x - x) + (vertex.y - y) * (vertex.y - y)) <= vertexRadius * vertexRadius) {
                        if (vertex.selected) {
                            selectedVertexesNumbers --;
                            vertex.selected = false;
                        }
                        else {
                            selectedVertexesNumbers ++;
                            vertex.selected = true;

                            if (firstSelectedVertex !== null)
                                secondSelectedVertex = vertex;

                            if (firstSelectedVertex === null)
                                firstSelectedVertex = vertex;
                        }
                    }

                })
        }

        draw();
    }

    document.querySelector("#canvas").addEventListener("click", clickOnPaintArea);


</script>

</html>